diff -uprN a/arch/arm/boot/dts/sun8i-v3s-funkey.dts b/arch/arm/boot/dts/sun8i-v3s-funkey.dts
--- a/arch/arm/boot/dts/sun8i-v3s-funkey.dts	2025-04-28 10:31:06.590409568 +0800
+++ b/arch/arm/boot/dts/sun8i-v3s-funkey.dts	2025-04-27 09:53:03.372561954 +0800
@@ -41,7 +41,7 @@
  */
 
 /dts-v1/;
-#include "sun8i-v3s.dtsi"
+#include "sun8i-v3s-test.dtsi"
 #include "sunxi-common-regulators.dtsi"
 
 / {
@@ -66,8 +66,109 @@
 
 	bat: battery {
 		compatible = "simple-battery";
-		constant_charge_current_max_microamp = <400000>;
+		constant_charge_current_max_microamp = <500000>;
 	};
+      
+      gpio_keys {
+            compatible = "gpio-keys-polled";
+            pinctrl-0 = <&key_pins>;
+            pinctrl-names = "default";
+            poll-interval = <20>;                           //20ms
+            autorepeat;
+            status = "okay";
+          
+            key_up {
+                  label = "UP";
+                  linux,code = <22>;
+                  gpios = <&pio 4 21 GPIO_ACTIVE_LOW>;      //KEY_U-PE21
+            };
+            
+            key_down {
+                  label = "DOWN";
+                  linux,code = <32>;
+                  gpios = <&pio 4 20 GPIO_ACTIVE_LOW>;      //KEY_D-PE20
+            };
+            
+            key_left {
+                  label = "LEFT";
+                  linux,code = <38>;
+                  gpios = <&pio 1 0 GPIO_ACTIVE_LOW>;       //KEY_L-PB0
+            };
+            
+            key_right {
+                  label = "RIGHT";
+                  linux,code = <19>;
+                  gpios = <&pio 4 19 GPIO_ACTIVE_LOW>;      //KEY_R-PE19
+            };
+            
+            key_start {
+                  label = "START";
+                  linux,code = <31>;
+                  gpios = <&pio 1 1 GPIO_ACTIVE_LOW>;       //KEY_S-PB1
+            };
+            
+            key_select {
+                  label = "SELECT";
+                  linux,code = <37>;
+                  gpios = <&pio 1 3 GPIO_ACTIVE_LOW>;       //KEY_K-PB3
+            };
+            
+            key_menu {
+                  label = "MENU";
+                  linux,code = <16>;
+                  gpios = <&pio 6 0 GPIO_ACTIVE_LOW>;       //KEY_Q-PG0
+            };
+            
+            key_b {
+                  label = "B";
+                  linux,code = <30>;
+                  gpios = <&pio 6 2 GPIO_ACTIVE_LOW>;       //KEY_B-PG2
+            };
+            
+            key_a {
+                  label = "A";
+                  linux,code = <48>;
+                  gpios = <&pio 6 1 GPIO_ACTIVE_LOW>;       //KEY_A-PG1
+            };
+            
+            key_x {
+                  label = "X";
+                  linux,code = <45>;
+                  gpios = <&pio 6 4 GPIO_ACTIVE_LOW>;       //KEY_X-PG4
+            };
+            
+            key_y {
+                  label = "Y";
+                  linux,code = <21>;
+                  gpios = <&pio 6 3 GPIO_ACTIVE_LOW>;       //KEY_Y-PG3
+            };
+            
+            key_l1 {
+                  label = "L1";
+                  linux,code = <50>;
+                  gpios = <&pio 4 22 GPIO_ACTIVE_LOW>;       //KEY_M-PE22
+            };
+            
+            key_r1 {
+                  label = "R1";
+                  linux,code = <49>;
+                  gpios = <&pio 6 5 GPIO_ACTIVE_LOW>;       //KEY_N-PG5
+            };
+      };
+};
+
+&tcon0 {
+      status = "okay";
+};
+
+&pio {
+      key_pins: gpio_pin@0 {
+            pins = "PG0", "PG1", "PG2", "PG3",
+                  "PG4", "PG5", "PE19", "PE20",
+                  "PE21", "PE22", "PB0", "PB1", "PB3";
+            function = "gpio_in";
+            bias-pull-up;
+      };
 };
 
 &codec {
@@ -114,13 +215,37 @@
 	status = "okay";
 };
 
-#include "axp209.dtsi"
+&spi0 {
+      status = "okay";
+};
 
-&ac_power_supply {
+&uart0 {
+	pinctrl-0 = <&uart0_pins_a>;
+	pinctrl-names = "default";
 	status = "okay";
 };
 
-&axp_gpio {
+&pwm {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pwm0_pins>;
+        status = "okay";
+};
+
+&usb_otg {
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usbphy {
+	usb0_vbus-supply = <&reg_vcc5v0>;
+	phy-supply = <&reg_vcc5v0>;
+	vcc = <&reg_vcc5v0>;
+	status = "okay";
+};
+
+#include "axp209.dtsi"
+
+&ac_power_supply {
 	status = "okay";
 };
 
@@ -174,69 +299,3 @@
 	regulator-always-on;
 	status = "okay";
 };
-
-&spi0 {
-	status = "okay";
-
-	st7789v@0 {
-		compatible = "sitronix,st7789v";
-		reg = <0>;
-		
-		/* SPI freq 
-		62.5Mhz should be the max theoritical frequency 
-		to respect the display's 16ns minimum writing speed.
-		However, above 59Mhz, the SPI->GRAM writing speed is higher 
-		than the Display<-GRAM reading spead and it 
-		creates inconsistencies in the tearing line position. 
-		Theoritically there should be no tearing line at all.
-		*/
-		spi-max-frequency = <62500000>;
-		//spi-max-frequency = <59000000>;
-		
-		spi_async_mode = "true";
-		txbuflen = <115202>; // Not needed in async mode
-		fps = <100>; // Not needed in async mode
-		buswidth = <8>;
-
-		/* Hardware rotate (counter clockwise)
-		Note that 90 or 270 without tearing 
-		is impossible even with TE synchro 
-		since there isn't the equivalent of 
-		MV (x/y inversion) for the display 
-		read (from GRAM) order */
-		rotate = <0>;	
-		
-		/* Software rotate (Clockwise)
-		0, 90 or 270 accepted */
-		rotate_soft = <270>; 
-
-		debug = <0>;	
-		reset-gpios = <&pio 1 2 GPIO_ACTIVE_HIGH>;	//PB2
-		dc-gpios = <&pio 2 0 GPIO_ACTIVE_LOW>;		//PC0 (MISO)
-		te-irq = <&pio 1 1 GPIO_ACTIVE_LOW>;		//PB1
-	};
-};
-
-&uart0 {
-	pinctrl-0 = <&uart0_pins_a>;
-	pinctrl-names = "default";
-	status = "okay";
-};
-
-&pwm {
-        pinctrl-names = "default";
-        pinctrl-0 = <&pwm0_pins>;
-        status = "okay";
-};
-
-&usb_otg {
-	dr_mode = "peripheral";
-	status = "okay";
-};
-
-&usbphy {
-	usb0_vbus-supply = <&reg_vcc5v0>;
-	phy-supply = <&reg_vcc5v0>;
-	vcc = <&reg_vcc5v0>;
-	status = "okay";
-};
diff -uprN a/arch/arm/boot/dts/sun8i-v3s-test.dtsi b/arch/arm/boot/dts/sun8i-v3s-test.dtsi
--- a/arch/arm/boot/dts/sun8i-v3s-test.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ b/arch/arm/boot/dts/sun8i-v3s-test.dtsi	2025-04-27 09:53:03.372561954 +0800
@@ -0,0 +1,420 @@
+/*
+ * Copyright (C) 2016 Icenowy Zheng <icenowy@aosc.xyz>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/sun8i-v3s-ccu.h>
+#include <dt-bindings/reset/sun8i-v3s-ccu.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&gic>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <0>;
+			clocks = <&ccu CLK_CPU>;
+                        clock-latency = <244144>; /* 8 32k periods */
+                        clock-frequency = <1296000>;
+                        operating-points = <
+                                /* kHz    uV */
+                                1296000 1200000
+                                1008000 1200000
+                                864000  1200000
+                                720000  1100000
+                                480000  1000000
+                                >;
+
+		};
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc24M: osc24M_clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			clock-accuracy = <50000>;
+			clock-output-names = "osc24M";
+		};
+
+		osc32k: osc32k_clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+			clock-accuracy = <50000>;
+			clock-output-names = "ext-osc32k";
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		syscon: syscon@1c00000 {
+			compatible = "allwinner,sun8i-v3s-system-controller",
+				"syscon";
+			reg = <0x01c00000 0x1000>;
+		};
+
+		tcon0: lcd-controller@1c0c000 {
+			compatible = "allwinner,sun8i-v3s-tcon0";
+			reg = <0x01c0c000 0x1000>;
+			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_TCON0>, <&ccu CLK_TCON0>;
+                  resets = <&ccu RST_BUS_TCON0>;
+			reset-names = "lcd";
+			status = "disabled";
+		};
+
+		dma: dma-controller@01c02000 {
+			compatible = "allwinner,sun8i-v3s-dma";
+			reg = <0x01c02000 0x1000>;
+			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_DMA>;
+			resets = <&ccu RST_BUS_DMA>;
+			#dma-cells = <1>;
+		};
+
+		mmc0: mmc@01c0f000 {
+			compatible = "allwinner,sun7i-a20-mmc";
+			reg = <0x01c0f000 0x1000>;
+			clocks = <&ccu CLK_BUS_MMC0>,
+				 <&ccu CLK_MMC0>,
+				 <&ccu CLK_MMC0_OUTPUT>,
+				 <&ccu CLK_MMC0_SAMPLE>;
+			clock-names = "ahb",
+				      "mmc",
+				      "output",
+				      "sample";
+			resets = <&ccu RST_BUS_MMC0>;
+			reset-names = "ahb";
+			interrupts = <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mmc1: mmc@01c10000 {
+			compatible = "allwinner,sun7i-a20-mmc";
+			reg = <0x01c10000 0x1000>;
+			clocks = <&ccu CLK_BUS_MMC1>,
+				 <&ccu CLK_MMC1>,
+				 <&ccu CLK_MMC1_OUTPUT>,
+				 <&ccu CLK_MMC1_SAMPLE>;
+			clock-names = "ahb",
+				      "mmc",
+				      "output",
+				      "sample";
+			resets = <&ccu RST_BUS_MMC1>;
+			reset-names = "ahb";
+			interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&mmc1_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		usb_otg: usb@01c19000 {
+			compatible = "allwinner,sun8i-h3-musb";
+			reg = <0x01c19000 0x0400>;
+			clocks = <&ccu CLK_BUS_OTG>;
+			resets = <&ccu RST_BUS_OTG>;
+			interrupts = <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "mc";
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			extcon = <&usbphy 0>;
+			status = "disabled";
+		};
+
+		usbphy: phy@01c19400 {
+			compatible = "allwinner,sun8i-v3s-usb-phy";
+			reg = <0x01c19400 0x2c>,
+			      <0x01c1a800 0x4>;
+			reg-names = "phy_ctrl",
+				    "pmu0";
+			clocks = <&ccu CLK_USB_PHY0>;
+			clock-names = "usb0_phy";
+			resets = <&ccu RST_USB_PHY0>;
+			reset-names = "usb0_reset";
+			status = "disabled";
+			#phy-cells = <1>;
+		};
+
+		ehci0: usb@01c1a000 {
+			compatible = "allwinner,sun8i-v3s-ehci", "generic-ehci";
+			reg = <0x01c1a000 0x100>;
+			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_EHCI0>, <&ccu CLK_BUS_OHCI0>;
+			resets = <&ccu RST_BUS_EHCI0>, <&ccu RST_BUS_OHCI0>;
+			status = "disabled";
+		};
+
+		ohci0: usb@01c1a400 {
+			compatible = "allwinner,sun8i-v3s-ohci", "generic-ohci";
+			reg = <0x01c1a400 0x100>;
+			interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_EHCI0>, <&ccu CLK_BUS_OHCI0>,
+				 <&ccu CLK_USB_OHCI0>;
+			resets = <&ccu RST_BUS_EHCI0>, <&ccu RST_BUS_OHCI0>;
+			status = "disabled";
+		};
+
+		ccu: clock@01c20000 {
+			compatible = "allwinner,sun8i-v3s-ccu";
+			reg = <0x01c20000 0x400>;
+			clocks = <&osc24M>, <&rtc 0>;
+			clock-names = "hosc", "losc";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		rtc: rtc@01c20400 {
+			#clock-cells = <1>;
+			compatible = "allwinner,sun8i-v3-rtc";
+			reg = <0x01c20400 0x54>;
+			interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&osc32k>;
+			clock-output-names = "osc32k", "osc32k-out";
+		};
+
+		pio: pinctrl@01c20800 {
+			compatible = "allwinner,sun8i-v3s-pinctrl";
+			reg = <0x01c20800 0x400>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_PIO>, <&osc24M>, <&rtc 0>;
+			clock-names = "apb", "hosc", "losc";
+			gpio-controller;
+			#gpio-cells = <3>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+
+			i2c0_pins: i2c0 {
+				pins = "PB6", "PB7";
+				function = "i2c0";
+			};
+
+			pwm0_pins: pwm0 {
+				pins = "PB4";
+				function = "pwm0";
+			};
+
+			uart0_pins_a: uart0@0 {
+				pins = "PB8", "PB9";
+				function = "uart0";
+			};
+
+			mmc0_pins_a: mmc0@0 {
+				pins = "PF0", "PF1", "PF2", "PF3",
+				       "PF4", "PF5";
+				function = "mmc0";
+				drive-strength = <30>;
+				bias-pull-up;
+			};
+
+			mmc1_pins: mmc1 {
+				pins = "PG0", "PG1", "PG2", "PG3",
+				       "PG4", "PG5";
+				function = "mmc1";
+				drive-strength = <30>;
+				bias-pull-up;
+			};
+
+			spi0_pins: spi0 {
+				pins = "PC0", "PC1", "PC2", "PC3";
+				function = "spi0";
+			};
+		};
+
+		timer@01c20c00 {
+			compatible = "allwinner,sun4i-a10-timer";
+			reg = <0x01c20c00 0xa0>;
+			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&osc24M>;
+		};
+
+		wdt0: watchdog@01c20ca0 {
+			compatible = "allwinner,sun6i-a31-wdt";
+			reg = <0x01c20ca0 0x20>;
+			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		pwm: pwm@1c21400 {
+			compatible = "allwinner,sun8i-v3s-pwm",
+				     "allwinner,sun7i-a20-pwm";
+			reg = <0x01c21400 0x400>;
+			clocks = <&osc24M>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		lradc: lradc@1c22800 {
+			compatible = "allwinner,sun4i-a10-lradc-keys";
+			reg = <0x01c22800 0x400>;
+			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		codec: codec@01c22c00 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun8i-v3s-codec";
+			reg = <0x01c22c00 0x400>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_CODEC>, <&ccu CLK_AC_DIG>;
+			clock-names = "apb", "codec";
+			resets = <&ccu RST_BUS_CODEC>;
+			dmas = <&dma 15>, <&dma 15>;
+			dma-names = "rx", "tx";
+			allwinner,codec-analog-controls = <&codec_analog>;
+			status = "disabled";
+		};
+
+		codec_analog: codec-analog@01c23000 {
+			compatible = "allwinner,sun8i-v3s-codec-analog";
+			reg = <0x01c23000 0x4>;
+			status = "disabled";
+		};
+
+		uart0: serial@01c28000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x01c28000 0x400>;
+			interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART0>;
+			resets = <&ccu RST_BUS_UART0>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@01c2ac00 {
+			compatible = "allwinner,sun6i-a31-i2c";
+			reg = <0x01c2ac00 0x400>;
+			interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C0>;
+			resets = <&ccu RST_BUS_I2C0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c0_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		emac: ethernet@1c30000 {
+			compatible = "allwinner,sun8i-v3s-emac";
+			syscon = <&syscon>;
+			reg = <0x01c30000 0x10000>;
+			interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			resets = <&ccu RST_BUS_EMAC>;
+			reset-names = "stmmaceth";
+			clocks = <&ccu CLK_BUS_EMAC>;
+			clock-names = "stmmaceth";
+			phy-handle = <&int_mii_phy>;
+			phy-mode = "mii";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			mdio {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				int_mii_phy: ethernet-phy@1 {
+					compatible = "ethernet-phy-ieee802.3-c22";
+					reg = <1>;
+					clocks = <&ccu CLK_BUS_EPHY>;
+					resets = <&ccu RST_BUS_EPHY>;
+					phy-is-integrated;
+				};
+			};
+		};
+
+		spi0: spi@1c68000 {
+			compatible = "allwinner,sun8i-h3-spi";
+			reg = <0x01c68000 0x1000>;
+			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>;
+			clock-names = "ahb", "mod";
+			dmas = <&dma 23>, <&dma 23>;
+			dma-names = "rx", "tx";
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0_pins>;
+			resets = <&ccu RST_BUS_SPI0>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		gic: interrupt-controller@01c81000 {
+			compatible = "arm,cortex-a7-gic", "arm,cortex-a15-gic";
+			reg = <0x01c81000 0x1000>,
+			      <0x01c82000 0x1000>,
+			      <0x01c84000 0x2000>,
+			      <0x01c86000 0x2000>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+		};
+	};
+};
diff -uprN a/build.sh b/build.sh
--- a/build.sh	1970-01-01 08:00:00.000000000 +0800
+++ b/build.sh	2025-04-28 10:19:41.241992624 +0800
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+export ARCH=arm
+export CROSS_COMPILE=/opt/FunKey-sdk-2.3.0/bin/arm-funkey-linux-gnueabihf-
+
+make -j1 V=s
+#make modules_install INSTALL_MOD_PATH="bin"
\ No newline at end of file
diff -uprN a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
--- a/drivers/video/fbdev/Kconfig	2025-04-28 10:01:02.355055903 +0800
+++ b/drivers/video/fbdev/Kconfig	2025-04-28 10:36:46.924833125 +0800
@@ -2495,4 +2495,22 @@ config FB_SM712
 
 	  This driver is also available as a module. The module will be
 	  called sm712fb. If you want to compile it as a module, say M
-	  here and read <file:Documentation/kbuild/modules.txt>.
\ No newline at end of file
+	  here and read <file:Documentation/kbuild/modules.txt>.
+	  
+config FB_V3S_ST7789V2
+	tristate "V3S_ST7789V2 SLCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for V3S_ST7789V2 SLCD panel.
+
+config FB_V3S_GC9307
+	tristate "V3S_GC9307 SLCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for V3S_GC9307 SLCD panel.
\ No newline at end of file
diff -uprN a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
--- a/drivers/video/fbdev/Makefile	2025-04-28 10:01:24.622158360 +0800
+++ b/drivers/video/fbdev/Makefile	2025-04-28 10:37:13.619737313 +0800
@@ -149,4 +149,6 @@ obj-$(CONFIG_FB_SSD1307)	  += ssd1307fb.
 obj-$(CONFIG_FB_SIMPLE)           += simplefb.o
 
 # the test framebuffer is last
-obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
\ No newline at end of file
+obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
+obj-$(CONFIG_FB_V3S_ST7789V2)	+= v3s_st7789v2.o
+obj-$(CONFIG_FB_V3S_GC9307)		  += v3s_gc9307.o
\ No newline at end of file
diff -uprN a/drivers/video/fbdev/core/fbmem.c b/drivers/video/fbdev/core/fbmem.c
--- a/drivers/video/fbdev/core/fbmem.c	2025-04-28 10:02:02.992611815 +0800
+++ b/drivers/video/fbdev/core/fbmem.c	2025-04-24 13:09:14.719117700 +0800
@@ -32,9 +32,9 @@
 #include <linux/device.h>
 #include <linux/efi.h>
 #include <linux/fb.h>
-#include <linux/fbtft.h>
 #include <linux/fbcon.h>
 #include <linux/mem_encrypt.h>
+#include <linux/overflow.h>
 
 #include <asm/fb.h>
 
@@ -428,6 +428,9 @@ static void fb_do_show_logo(struct fb_in
 {
 	unsigned int x;
 
+	if (image->width > info->var.xres || image->height > info->var.yres)
+		return;
+
 	if (rotate == FB_ROTATE_UR) {
 		for (x = 0;
 		     x < num && image->dx + image->width <= info->var.xres;
@@ -436,7 +439,9 @@ static void fb_do_show_logo(struct fb_in
 			image->dx += image->width + 8;
 		}
 	} else if (rotate == FB_ROTATE_UD) {
-		for (x = 0; x < num; x++) {
+		u32 dx = image->dx;
+
+		for (x = 0; x < num && image->dx <= dx; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dx -= image->width + 8;
 		}
@@ -448,7 +453,9 @@ static void fb_do_show_logo(struct fb_in
 			image->dy += image->height + 8;
 		}
 	} else if (rotate == FB_ROTATE_CCW) {
-		for (x = 0; x < num; x++) {
+		u32 dy = image->dy;
+
+		for (x = 0; x < num && image->dy <= dy; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dy -= image->height + 8;
 		}
@@ -977,6 +984,7 @@ fb_set_var(struct fb_info *info, struct
 	if ((var->activate & FB_ACTIVATE_FORCE) ||
 	    memcmp(&info->var, var, sizeof(struct fb_var_screeninfo))) {
 		u32 activate = var->activate;
+		u32 unused;
 
 		/* When using FOURCC mode, make sure the red, green, blue and
 		 * transp fields are set to 0.
@@ -997,6 +1005,15 @@ fb_set_var(struct fb_info *info, struct
 			goto done;
 		}
 
+		/* bitfill_aligned() assumes that it's at least 8x8 */
+		if (var->xres < 8 || var->yres < 8)
+			return -EINVAL;
+
+		/* Too huge resolution causes multiplication overflow. */
+		if (check_mul_overflow(var->xres, var->yres, &unused) ||
+		    check_mul_overflow(var->xres_virtual, var->yres_virtual, &unused))
+			return -EINVAL;
+
 		ret = info->fbops->fb_check_var(var, info);
 
 		if (ret)
@@ -1128,7 +1145,7 @@ static long do_fb_ioctl(struct fb_info *
 	case FBIOGET_FSCREENINFO:
 		if (!lock_fb_info(info))
 			return -ENODEV;
-		fix = info->fix;
+		memcpy(&fix, &info->fix, sizeof(fix));
 		unlock_fb_info(info);
 
 		ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;
@@ -1148,7 +1165,6 @@ static long do_fb_ioctl(struct fb_info *
 		ret = fb_cmap_to_user(&cmap_from, &cmap);
 		break;
 	case FBIOPAN_DISPLAY:
-
 		if (copy_from_user(&var, argp, sizeof(var)))
 			return -EFAULT;
 		console_lock();
@@ -1157,10 +1173,6 @@ static long do_fb_ioctl(struct fb_info *
 			return -ENODEV;
 		}
 		ret = fb_pan_display(info, &var);
-
-		/** fbtft switch buffer */
-		fbtft_flip_backbuffer(info->par);
-		
 		unlock_fb_info(info);
 		console_unlock();
 		if (ret == 0 && copy_to_user(argp, &var, sizeof(var)))
@@ -1722,12 +1734,12 @@ static int do_register_framebuffer(struc
 	return 0;
 }
 
-static int do_unregister_framebuffer(struct fb_info *fb_info)
+static int unbind_console(struct fb_info *fb_info)
 {
 	struct fb_event event;
-	int i, ret = 0;
+	int ret;
+	int i = fb_info->node;
 
-	i = fb_info->node;
 	if (i < 0 || i >= FB_MAX || registered_fb[i] != fb_info)
 		return -EINVAL;
 
@@ -1742,17 +1754,29 @@ static int do_unregister_framebuffer(str
 	unlock_fb_info(fb_info);
 	console_unlock();
 
+	return ret;
+}
+
+static int __unlink_framebuffer(struct fb_info *fb_info);
+
+static int do_unregister_framebuffer(struct fb_info *fb_info)
+{
+	struct fb_event event;
+	int ret;
+
+	ret = unbind_console(fb_info);
+
 	if (ret)
 		return -EINVAL;
 
 	pm_vt_switch_unregister(fb_info->dev);
 
-	unlink_framebuffer(fb_info);
+	__unlink_framebuffer(fb_info);
 	if (fb_info->pixmap.addr &&
 	    (fb_info->pixmap.flags & FB_PIXMAP_DEFAULT))
 		kfree(fb_info->pixmap.addr);
 	fb_destroy_modelist(&fb_info->modelist);
-	registered_fb[i] = NULL;
+	registered_fb[fb_info->node] = NULL;
 	num_registered_fb--;
 	fb_cleanup_device(fb_info);
 	event.info = fb_info;
@@ -1765,7 +1789,7 @@ static int do_unregister_framebuffer(str
 	return 0;
 }
 
-int unlink_framebuffer(struct fb_info *fb_info)
+static int __unlink_framebuffer(struct fb_info *fb_info)
 {
 	int i;
 
@@ -1777,6 +1801,20 @@ int unlink_framebuffer(struct fb_info *f
 		device_destroy(fb_class, MKDEV(FB_MAJOR, i));
 		fb_info->dev = NULL;
 	}
+
+	return 0;
+}
+
+int unlink_framebuffer(struct fb_info *fb_info)
+{
+	int ret;
+
+	ret = __unlink_framebuffer(fb_info);
+	if (ret)
+		return ret;
+
+	unbind_console(fb_info);
+
 	return 0;
 }
 EXPORT_SYMBOL(unlink_framebuffer);
@@ -1962,4 +2000,4 @@ int fb_new_modelist(struct fb_info *info
 	return err;
 }
 
-MODULE_LICENSE("GPL");
\ No newline at end of file
+MODULE_LICENSE("GPL");
diff -uprN a/drivers/video/fbdev/v3s_gc9307.c b/drivers/video/fbdev/v3s_gc9307.c
--- a/drivers/video/fbdev/v3s_gc9307.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/fbdev/v3s_gc9307.c	2025-04-28 09:56:39.445656253 +0800
@@ -0,0 +1,717 @@
+#include <asm/io.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
+#include <linux/omapfb.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "v3s_i80.h"
+
+struct myfb_par {
+    struct device *dev;
+    struct platform_device *pdev;
+
+    resource_size_t p_palette_base;
+    unsigned short *v_palette_base;
+
+    int yoffset;
+    void *vram_virt;
+    uint32_t vram_size;
+    dma_addr_t vram_phys;
+
+    int bpp;
+    int lcdc_irq;
+    uint32_t pseudo_palette[16];
+    struct fb_videomode mode;
+};
+
+struct v3s_iomm {
+    uint8_t *ccm;
+    uint8_t *gpio;
+    uint8_t *lcdc;
+    uint8_t *de;
+};
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static struct timer_list mytimer;
+static struct v3s_iomm iomm = {0};
+static struct myfb_par *mypar = NULL;
+static struct fb_var_screeninfo myfb_var = {0};
+static struct fb_fix_screeninfo myfb_fix = {
+    .id = DRIVER_NAME,
+    .type = FB_TYPE_PACKED_PIXELS,
+    .type_aux = 0,
+    .visual = FB_VISUAL_TRUECOLOR,
+    .xpanstep = 0,
+    .ypanstep = 1,
+    .ywrapstep = 0,
+    .accel = FB_ACCEL_NONE
+};
+
+static void v3s_clrbits(void __iomem *reg, uint32_t clr_val)
+{
+	uint32_t ret;
+
+	ret = readl(reg);
+	ret &= ~(clr_val);
+	writel(ret, reg);
+}
+
+static void v3s_setbits(void __iomem *reg, uint32_t set_val)
+{
+	uint32_t ret;
+
+	ret = readl(reg);
+	ret |= set_val;
+	writel(ret, reg);
+}
+
+static void v3s_i80_gpio_init(void)
+{
+    uint32_t r=0;
+
+    //PE0~7
+    r = readl(iomm.gpio + V3S_GPIOE_CFG0);
+    r&= 0x000f0000;
+    r|= 0x33303333;
+    writel(r, iomm.gpio + V3S_GPIOE_CFG0);
+
+    //PE8~15
+    r = readl(iomm.gpio + V3S_GPIOE_CFG1);
+    r&= 0xfff00000;
+    r|= 0x00033333;
+    writel(r, iomm.gpio + V3S_GPIOE_CFG1);
+
+    //PE2
+    r = readl(iomm.gpio + V3S_GPIOE_PUL0);
+    r &= 0xffffff0f;
+    r |= 0x00000010;
+    writel(r, iomm.gpio + V3S_GPIOE_PUL0);
+
+    //PB2
+    r = readl(iomm.gpio + V3S_GPIOB_CFG0);
+    r&= 0xfffff0ff;
+    r|= 0x00000100;
+    writel(r, iomm.gpio + V3S_GPIOB_CFG0);
+
+    //LCDreset
+    v3s_clrbits(iomm.gpio + V3S_GPIOB_DATA, (1 << 2));
+    mdelay(150);
+    v3s_setbits(iomm.gpio + V3S_GPIOB_DATA, (1 << 2));
+    mdelay(50);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+    uint32_t cnt = 0;
+
+    v3s_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));   //trigger mode enable
+    ndelay(10);
+    while(1) {
+        if(readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000) {
+            if(cnt > 100) {
+                return -1;
+            }
+            else {
+                cnt += 1;
+            }
+        }
+        break;
+    }
+    return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+    return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+    while(lcdc_wait_busy());
+    if(is_data) {
+        v3s_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    else {
+        v3s_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    while(lcdc_wait_busy());
+    writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+static void lcdc_st7789v_init(void)
+{
+    v3s_i80_gpio_init();
+
+    lcdc_wr(0, 0x11);  //sleep out
+    mdelay(250);
+
+    lcdc_wr(0, 0x36);
+    lcdc_wr(1, 0xB0);
+
+    lcdc_wr(0, 0x2a);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x01);
+    lcdc_wr(1, 0x3f);
+
+    lcdc_wr(0, 0x2b);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0xef);
+
+    // ST7789S Frame rate setting
+    lcdc_wr(0, 0xb2);
+    lcdc_wr(1, 0x0c);
+    lcdc_wr(1, 0x0c);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x33);
+    lcdc_wr(1, 0x33);
+
+    lcdc_wr(0, 0x20);  //Display Inversion Off
+
+    // Gate Control
+    lcdc_wr(0, 0xb7);
+    lcdc_wr(1, 0x56);
+
+    // ST7789S Power setting
+    lcdc_wr(0, 0xbb);
+    lcdc_wr(1, 0x18);
+
+    lcdc_wr(0, 0xc0);
+    lcdc_wr(1, 0x2c);
+
+    lcdc_wr(0, 0xc2);
+    lcdc_wr(1, 0x01);
+
+    lcdc_wr(0, 0xc3);
+    lcdc_wr(1, 0x1f);
+
+    lcdc_wr(0, 0xc4);
+    lcdc_wr(1, 0x20);
+
+    lcdc_wr(0, 0xc6);
+    lcdc_wr(1, 0x0f); // 0x04, 0x1f
+
+    lcdc_wr(0, 0xd0);
+    lcdc_wr(1, 0xa6);
+    lcdc_wr(1, 0xa1);
+
+    // ST7789S gamma setting
+    lcdc_wr(0, 0xe0);
+    lcdc_wr(1, 0x70);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x06);
+    lcdc_wr(1, 0x09);
+    lcdc_wr(1, 0x0b);
+    lcdc_wr(1, 0x2a);
+    lcdc_wr(1, 0x3c);
+    lcdc_wr(1, 0x33);
+    lcdc_wr(1, 0x4b);
+    lcdc_wr(1, 0x08);
+    lcdc_wr(1, 0x16);
+    lcdc_wr(1, 0x14);
+    lcdc_wr(1, 0x2a);
+    lcdc_wr(1, 0x23);
+
+    lcdc_wr(0, 0xe1);
+    lcdc_wr(1, 0xd0);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x06);
+    lcdc_wr(1, 0x09);
+    lcdc_wr(1, 0x0b);
+    lcdc_wr(1, 0x29);
+    lcdc_wr(1, 0x36);
+    lcdc_wr(1, 0x54);
+    lcdc_wr(1, 0x4b);
+    lcdc_wr(1, 0x0d);
+    lcdc_wr(1, 0x16);
+    lcdc_wr(1, 0x14);
+    lcdc_wr(1, 0x28);
+    lcdc_wr(1, 0x22);
+
+    lcdc_wr(0, 0x35);  //Memory data access control
+    lcdc_wr(1, 0x00);  //TE off
+    lcdc_wr(1, 0xaa);  //4us
+    lcdc_wr(1, 0x55);  //4us
+    lcdc_wr(1, 0x21);  //TE on
+
+    lcdc_wr(0, 0x3A);  //Interface pixel format
+    lcdc_wr(1, 0x55);  //65K
+
+    lcdc_wr(0, 0x21);  //ips Display inversion on
+    lcdc_wr(0, 0x29);  //Display on
+    lcdc_wr(0, 0x2c);  //Memory write
+}
+
+static void smartlcd_init(struct myfb_par *par)
+{
+    uint32_t ret=0, bp=0, total=0, i=0;
+    uint32_t h_front_porch = 8;
+    uint32_t h_back_porch = 8;
+    uint32_t h_sync_len = 1;
+    uint32_t v_front_porch = 10;
+    uint32_t v_back_porch = 110;
+    uint32_t v_sync_len = 1;
+
+    struct de_clk_t * clk = (struct de_clk_t *)(iomm.de);
+	struct de_glb_t * glb = (struct de_glb_t *)(iomm.de + V3S_DE_MUX_GLB);
+	struct de_bld_t * bld = (struct de_bld_t *)(iomm.de + V3S_DE_MUX_BLD);
+	struct de_ui_t * ui = (struct de_ui_t *)(iomm.de + V3S_DE_MUX_CHAN + 0x1000 * 2);
+
+    //tcon0 disable
+    writel(0, iomm.lcdc + TCON_CTRL_REG);
+    writel(0, iomm.lcdc + TCON_INT_REG0);
+    ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+    ret &= ~(0xf << 28);
+    writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    //de set mod
+    v3s_setbits(&clk->rst_cfg, (1 << 0));
+    v3s_setbits(&clk->gate_cfg, (1 << 0));
+    v3s_setbits(&clk->bus_cfg, (1 << 0));
+    v3s_setbits(&clk->sel_cfg, (1 << 0));
+
+    v3s_setbits(&glb->ctl, (1 << 0));
+    writel(0, &glb->status);
+    writel(1, &glb->dbuff);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &glb->size);
+
+    for(i = 0; i < 4; i++) {
+		void * chan = (void *)(iomm.de + V3S_DE_MUX_CHAN + 0x1000 * i);
+		memset(chan, 0, i == 0 ? sizeof(struct de_vi_t) : sizeof(struct de_ui_t));
+	}
+	memset(bld, 0, sizeof(struct de_bld_t));
+
+    writel(0x00000101, &bld->fcolor_ctl);
+	writel(2, &bld->route);
+	writel(0, &bld->premultiply);
+	writel(0xff000000, &bld->bkcolor);
+	writel(0x03010301, &bld->bld_mode[0]);
+	writel(0x03010301, &bld->bld_mode[1]);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &bld->output_size);
+	writel(0, &bld->out_ctl);
+	writel(0, &bld->ck_ctl);
+
+	for(i = 0; i < 4; i++) {
+		writel(0xff000000, &bld->attr[i].fcolor);
+		writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &bld->attr[i].insize);
+	}
+
+    writel(0, iomm.de + V3S_DE_MUX_VSU);
+	writel(0, iomm.de + V3S_DE_MUX_GSU1);
+	writel(0, iomm.de + V3S_DE_MUX_GSU2);
+	writel(0, iomm.de + V3S_DE_MUX_GSU3);
+	writel(0, iomm.de + V3S_DE_MUX_FCE);
+	writel(0, iomm.de + V3S_DE_MUX_BWS);
+	writel(0, iomm.de + V3S_DE_MUX_LTI);
+	writel(0, iomm.de + V3S_DE_MUX_PEAK);
+	writel(0, iomm.de + V3S_DE_MUX_ASE);
+	writel(0, iomm.de + V3S_DE_MUX_FCC);
+	writel(0, iomm.de + V3S_DE_MUX_DCSC);
+
+	writel((1 << 0) | (10 << 8) | (1 << 1) | (0xff << 24), &ui->cfg[0].attr);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &ui->cfg[0].size);
+	writel(0, &ui->cfg[0].coord);
+	writel(4 * (par->mode.xres), &ui->cfg[0].pitch);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &ui->ovl_size);
+
+    //de set address
+	writel((uint32_t)par->vram_phys, &ui->cfg[0].top_laddr);
+
+    //de enable
+    writel(1, &glb->dbuff);
+
+    //tcon set mode
+    ret = (v_front_porch + v_back_porch + v_sync_len);
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+    writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel((7 << 29), iomm.lcdc + TCON0_CPU_IF_REG);
+
+    writel(((par->mode.xres - 1) << 16) | ((par->mode.yres - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+    bp = h_sync_len + h_back_porch;
+    total = (par->mode.xres) * 3 / 2 + h_front_porch + bp;
+    writel(((total - 1) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+    bp = v_sync_len + v_back_porch;
+    total = par->mode.yres + v_front_porch + bp;
+    writel(((total * 2) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+    writel(((h_sync_len - 1) << 16) | ((v_sync_len - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+
+    writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+    writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+    writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    writel(((((par->mode.xres) / 2 + h_front_porch + bp - 1) << 16)), iomm.lcdc + TCON0_CPU_TRI0_REG);   //block space
+    writel((par->mode.yres - 1), iomm.lcdc + TCON0_CPU_TRI1_REG);   //block num
+    writel(((7 << 15) | (par->mode.xres - 1)), iomm.lcdc + TCON0_CPU_TRI2_REG);//start delay3, Trans Start
+    v3s_setbits(iomm.lcdc + TCON0_CPU_TRI3_REG, (2 << 28));         //TE falling mode
+
+    //tcon enable
+    v3s_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+    lcdc_st7789v_init();
+
+    v3s_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 26));
+    v3s_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+    v3s_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 26) | (1 << 17));
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg) {
+    v3s_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 10));
+    return IRQ_HANDLED;
+}
+
+static void v3s_enable_irq(struct myfb_par *par)
+{
+    int ret = 0;
+
+    par->lcdc_irq = platform_get_irq(par->pdev, 0);
+    if(par->lcdc_irq < 0) {
+        printk("%s, failed to get irq number for lcdc irq\n", __func__);
+    }
+    else {
+        ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "lcdc_irq", par);
+        if(ret) {
+            printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+        }
+    }
+}
+
+static void v3s_clock_init(struct myfb_par *par)
+{
+    writel(0x91001304, iomm.ccm + PLL_VIDEO_CTRL_REG);
+    while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+    while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+    v3s_setbits(iomm.ccm + DE_CLK_REG, (1 << 31));
+    v3s_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31));
+    v3s_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 12) | (1 << 4));
+    v3s_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 12) | (1 << 4));
+}
+
+static void lcd_delay_init(unsigned long param)
+{
+    v3s_clock_init(mypar);
+    smartlcd_init(mypar);
+    v3s_enable_irq(mypar);
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+    red = CNVT_TOHW(red, info->var.red.length);
+    blue = CNVT_TOHW(blue, info->var.blue.length);
+    green = CNVT_TOHW(green, info->var.green.length);
+    ((uint32_t *)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+    return 0;
+}
+#undef CNVT_TOHW
+
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    int bpp = var->bits_per_pixel >> 3;
+    struct myfb_par *par = info->par;
+    unsigned long line_size = var->xres_virtual * bpp;
+
+    if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)) {
+        return -EINVAL;
+    }
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->red.offset = 11;
+    var->red.length = 5;
+    var->green.offset = 5;
+    var->green.length = 6;
+    var->blue.offset = 0;
+    var->blue.length = 5;
+    var->red.msb_right = 0;
+    var->green.msb_right = 0;
+    var->blue.msb_right = 0;
+    var->transp.msb_right = 0;
+    if(line_size * var->yres_virtual > par->vram_size) {
+        var->yres_virtual = par->vram_size / line_size;
+    }
+    if(var->yres > var->yres_virtual) {
+        var->yres = var->yres_virtual;
+    }
+    if(var->xres > var->xres_virtual) {
+        var->xres = var->xres_virtual;
+    }
+    if(var->xres + var->xoffset > var->xres_virtual) {
+        var->xoffset = var->xres_virtual - var->xres;
+    }
+    if(var->yres + var->yoffset > var->yres_virtual) {
+        var->yoffset = var->yres_virtual - var->yres;
+    }
+    return 0;
+}
+
+static int myfb_set_par(struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    fb_var_to_videomode(&par->mode, &info->var);
+    par->yoffset = info->var.yoffset;
+    par->bpp = info->var.bits_per_pixel;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.line_length = (par->mode.xres * par->bpp) / 8;
+
+    return 0;
+}
+
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+    switch (cmd) {
+        case FBIO_WAITFORVSYNC:
+            break;			
+    }
+    return 0;
+}
+
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+    const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+    const unsigned long size = vma->vm_end - vma->vm_start;
+
+    if(offset + size > info->fix.smem_len) {
+        return -EINVAL;
+    }
+
+    if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)) {
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    if((var->xoffset != info->var.xoffset) || (var->yoffset != info->var.yoffset)){
+        info->var.xoffset = var->xoffset;
+        info->var.yoffset = var->yoffset;
+        par->yoffset = var->yoffset;
+    }
+    return 0;
+}
+
+static struct fb_ops myfb_ops = {
+    .owner          = THIS_MODULE,
+    .fb_check_var   = myfb_check_var,
+    .fb_set_par     = myfb_set_par,
+    .fb_setcolreg   = myfb_setcolreg,
+    .fb_pan_display = myfb_pan_display,
+    .fb_ioctl       = myfb_ioctl,
+    .fb_mmap        = myfb_mmap,
+
+    .fb_fillrect  = sys_fillrect,
+    .fb_copyarea  = sys_copyarea,
+    .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+    int ret = 0;
+    struct fb_info *info = NULL;
+    struct myfb_par *par = NULL;
+    struct fb_videomode *mode = NULL;
+
+    mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+    if(mode == NULL) {
+        return -ENOMEM;
+    }
+    mode->name = "320x240";
+    mode->xres = 320;
+    mode->yres = 240;
+    mode->vmode = FB_VMODE_NONINTERLACED;
+    pm_runtime_enable(&device->dev);
+    pm_runtime_get_sync(&device->dev);
+
+    info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+    if(!info) {
+        return -ENOMEM;
+    }
+
+    par = info->par;
+    par->pdev = device;
+    par->dev = &device->dev;
+    par->bpp = 16;
+    fb_videomode_to_var(&myfb_var, mode);
+
+    par->vram_size = (320 * 240 * 2 * 2);
+    par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t *)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+    if(!par->vram_virt) {
+        return -EINVAL;
+    }
+    info->screen_base = (char __iomem *)par->vram_virt;
+    myfb_fix.smem_start = par->vram_phys;
+    myfb_fix.smem_len = par->vram_size;
+    myfb_fix.line_length = 320 * 2;
+
+    par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t *)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+    if(!par->v_palette_base) {
+        return -EINVAL;
+    }
+    memset(par->v_palette_base, 0, PALETTE_SIZE);
+    myfb_var.grayscale = 0;
+    myfb_var.bits_per_pixel = par->bpp;
+
+    info->flags = FBINFO_FLAG_DEFAULT;
+    info->fix = myfb_fix;
+    info->var = myfb_var;
+    info->fbops = &myfb_ops;
+    info->pseudo_palette = par->pseudo_palette;
+    info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+    ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+    if(ret) {
+        return -EINVAL;
+    }
+    info->cmap.len = 32;
+
+    myfb_var.activate = FB_ACTIVATE_FORCE;
+    fb_set_var(info, &myfb_var);
+    dev_set_drvdata(&device->dev, info);
+    if(register_framebuffer(info) < 0) {
+        return -EINVAL;
+    }
+
+    mypar = par;
+
+    for(ret = 0; ret < of_clk_get_parent_count(device->dev.of_node); ret++) {
+        clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+    }
+
+    setup_timer(&mytimer, lcd_delay_init, 0);
+    mod_timer(&mytimer, jiffies + HZ);
+
+    return 0;
+}
+
+static int myfb_remove(struct platform_device *dev)
+{
+    struct fb_info *info = dev_get_drvdata(&dev->dev);
+    struct myfb_par *par = info->par;
+
+    if(info) {
+        free_irq(par->lcdc_irq, par);
+        del_timer(&mytimer);
+        flush_scheduled_work();
+        unregister_framebuffer(info);
+        fb_dealloc_cmap(&info->cmap);
+        dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+        dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+        pm_runtime_put_sync(&dev->dev);
+        pm_runtime_disable(&dev->dev);
+        framebuffer_release(info);
+    }
+    return 0;
+}
+
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    fb_set_suspend(info, 1);
+    pm_runtime_put_sync(&dev->dev);
+    console_unlock();
+    return 0;
+}
+
+static int myfb_resume(struct platform_device *dev)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    pm_runtime_get_sync(&dev->dev);
+    fb_set_suspend(info, 0);
+    console_unlock();
+    return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+    {
+        .compatible = "allwinner,sun8i-v3s-tcon0",
+    },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+
+static struct platform_driver fb_driver = {
+    .probe    = myfb_probe,
+    .remove   = myfb_remove,
+    .suspend  = myfb_suspend,
+    .resume   = myfb_resume,
+    .driver = {
+        .name   = DRIVER_NAME,
+        .owner  = THIS_MODULE,
+        .of_match_table = of_match_ptr(fb_of_match),
+    },
+};
+
+static int myopen(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    return 0;
+}
+
+static const struct file_operations myfops = {
+        .owner = THIS_MODULE,
+        .open = myopen,
+        .release = myclose,
+        .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+    iomm.ccm = (uint8_t *)ioremap(V3S_CCM_BASE, 0x400);
+    iomm.gpio = (uint8_t *)ioremap(V3S_GPIO_BASE, 0x400);
+    iomm.lcdc = (uint8_t *)ioremap(V3S_TCON0_BASE, 0x1000);
+    iomm.de = (uint8_t *)ioremap(V3S_DE_BASE, 0x200000);
+    alloc_chrdev_region(&major, 0, 1, "miyoo_fb0");
+    myclass = class_create(THIS_MODULE, "miyoo_fb0");
+    device_create(myclass, NULL, major, NULL, "miyoo_fb0");
+    cdev_init(&mycdev, &myfops);
+    cdev_add(&mycdev, major, 1);
+    return platform_driver_register(&fb_driver);
+}
+
+static void __exit fb_cleanup(void)
+{
+    iounmap(iomm.ccm);
+    iounmap(iomm.gpio);
+    iounmap(iomm.lcdc);
+    iounmap(iomm.de);
+    device_destroy(myclass, major);
+    cdev_del(&mycdev);
+    class_destroy(myclass);
+    unregister_chrdev_region(major, 1);
+    platform_driver_unregister(&fb_driver);
+}
+
+module_init(fb_init);
+module_exit(fb_cleanup);
+
+MODULE_DESCRIPTION("I80 Framebuffer driver for V3S");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
diff -uprN a/drivers/video/fbdev/v3s_i80.h b/drivers/video/fbdev/v3s_i80.h
--- a/drivers/video/fbdev/v3s_i80.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/fbdev/v3s_i80.h	2025-04-28 09:56:39.445656253 +0800
@@ -0,0 +1,135 @@
+#ifndef V3S_I80_H
+#define V3S_I80_H
+
+#include <linux/types.h>
+
+#define V3S_CCM_BASE			(0x01C20000)
+#define PLL_VIDEO_CTRL_REG      (0x0010)
+#define PLL_PERIPH_CTRL_REG     (0x0028)
+#define PLL_PERIPH1_CTRL_REG    (0x0044)
+#define BUS_CLK_GATING_REG1     (0x0064)
+#define DE_CLK_REG              (0x0104)
+#define TCON_CLK_REG            (0x0118)
+#define BUS_SOFT_RST_REG1       (0x02C4)
+
+#define V3S_GPIO_BASE       	(0x01c20800)
+#define V3S_GPIOB_CFG0      	((1 * 0x24) + 0x00)
+#define V3S_GPIOB_DATA      	((1 * 0x24) + 0x10)
+#define V3S_GPIOE_CFG0      	((4 * 0x24) + 0x00)
+#define V3S_GPIOE_CFG1      	((4 * 0x24) + 0x04)
+#define V3S_GPIOE_DATA      	((4 * 0x24) + 0x10)
+#define V3S_GPIOE_PUL0     		((4*0x24)+0x1C)
+
+#define V3S_TCON0_BASE      	(0x01c0c000)
+#define TCON_CTRL_REG       	(0x000)
+#define TCON_INT_REG0       	(0x004)
+#define TCON0_CTRL_REG       	(0x040)
+#define TCON_CLK_CTRL_REG   	(0x044)
+#define TCON0_BASIC_TIMING_REG0	(0x048)
+#define TCON0_BASIC_TIMING_REG1	(0x04C)
+#define TCON0_BASIC_TIMING_REG2	(0x050)
+#define TCON0_BASIC_TIMING_REG3	(0x054)
+#define TCON0_HV_TIMING_REG		(0x058)
+#define TCON0_CPU_IF_REG    	(0x060)
+#define TCON0_CPU_WR_REG    	(0x064)
+#define TCON0_CPU_RD_REG        (0x068)
+#define TCON0_IO_CTRL_REG0  	(0x088)
+#define TCON0_IO_CTRL_REG1  	(0x08C)
+#define TCON0_CPU_TRI0_REG		(0x160)
+#define TCON0_CPU_TRI1_REG		(0x164)
+#define TCON0_CPU_TRI2_REG		(0x168)
+#define TCON0_CPU_TRI3_REG		(0x16C)
+
+#define V3S_DE_BASE				(0x01000000)
+#define V3S_DE_MUX_GLB			(0x00100000 + 0x00000)
+#define V3S_DE_MUX_BLD			(0x00100000 + 0x01000)
+#define V3S_DE_MUX_CHAN			(0x00100000 + 0x02000)
+#define V3S_DE_MUX_VSU			(0x00100000 + 0x20000)
+#define V3S_DE_MUX_GSU1			(0x00100000 + 0x30000)
+#define V3S_DE_MUX_GSU2			(0x00100000 + 0x40000)
+#define V3S_DE_MUX_GSU3			(0x00100000 + 0x50000)
+#define V3S_DE_MUX_FCE			(0x00100000 + 0xa0000)
+#define V3S_DE_MUX_BWS			(0x00100000 + 0xa2000)
+#define V3S_DE_MUX_LTI			(0x00100000 + 0xa4000)
+#define V3S_DE_MUX_PEAK			(0x00100000 + 0xa6000)
+#define V3S_DE_MUX_ASE			(0x00100000 + 0xa8000)
+#define V3S_DE_MUX_FCC			(0x00100000 + 0xaa000)
+#define V3S_DE_MUX_DCSC			(0x00100000 + 0xb0000)
+
+#define PALETTE_SIZE			256
+#define DRIVER_NAME				"v3s-i80"
+
+struct de_clk_t {
+	uint32_t gate_cfg;
+	uint32_t bus_cfg;
+	uint32_t rst_cfg;
+	uint32_t div_cfg;
+	uint32_t sel_cfg;
+};
+
+struct de_glb_t {
+	uint32_t ctl;
+	uint32_t status;
+	uint32_t dbuff;
+	uint32_t size;
+};
+
+struct de_bld_t {
+	uint32_t fcolor_ctl;
+	struct {
+		uint32_t fcolor;
+		uint32_t insize;
+		uint32_t offset;
+		uint32_t dum;
+	} attr[4];
+	uint32_t dum0[15];
+	uint32_t route;
+	uint32_t premultiply;
+	uint32_t bkcolor;
+	uint32_t output_size;
+	uint32_t bld_mode[4];
+	uint32_t dum1[4];
+	uint32_t ck_ctl;
+	uint32_t ck_cfg;
+	uint32_t dum2[2];
+	uint32_t ck_max[4];
+	uint32_t dum3[4];
+	uint32_t ck_min[4];
+	uint32_t dum4[3];
+	uint32_t out_ctl;
+};
+
+struct de_vi_t {
+	struct {
+		uint32_t attr;
+		uint32_t size;
+		uint32_t coord;
+		uint32_t pitch[3];
+		uint32_t top_laddr[3];
+		uint32_t bot_laddr[3];
+	} cfg[4];
+	uint32_t fcolor[4];
+	uint32_t top_haddr[3];
+	uint32_t bot_haddr[3];
+	uint32_t ovl_size[2];
+	uint32_t hori[2];
+	uint32_t vert[2];
+};
+
+struct de_ui_t {
+	struct {
+		uint32_t attr;
+		uint32_t size;
+		uint32_t coord;
+		uint32_t pitch;
+		uint32_t top_laddr;
+		uint32_t bot_laddr;
+		uint32_t fcolor;
+		uint32_t dum;
+	} cfg[4];
+	uint32_t top_haddr;
+	uint32_t bot_haddr;
+	uint32_t ovl_size;
+};
+
+#endif
\ No newline at end of file
diff -uprN a/drivers/video/fbdev/v3s_st7789v2.c b/drivers/video/fbdev/v3s_st7789v2.c
--- a/drivers/video/fbdev/v3s_st7789v2.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/fbdev/v3s_st7789v2.c	2025-04-28 09:56:39.445656253 +0800
@@ -0,0 +1,720 @@
+#include <asm/io.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
+#include <linux/omapfb.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "v3s_i80.h"
+
+struct myfb_par {
+    struct device *dev;
+    struct platform_device *pdev;
+
+    resource_size_t p_palette_base;
+    unsigned short *v_palette_base;
+
+    int yoffset;
+    void *vram_virt;
+    uint32_t vram_size;
+    dma_addr_t vram_phys;
+
+    int bpp;
+    int lcdc_irq;
+    uint32_t pseudo_palette[16];
+    struct fb_videomode mode;
+};
+
+struct v3s_iomm {
+    uint8_t *ccm;
+    uint8_t *gpio;
+    uint8_t *lcdc;
+    uint8_t *de;
+};
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static struct timer_list mytimer;
+static struct v3s_iomm iomm = {0};
+static struct myfb_par *mypar = NULL;
+static struct fb_var_screeninfo myfb_var = {0};
+static struct fb_fix_screeninfo myfb_fix = {
+    .id = DRIVER_NAME,
+    .type = FB_TYPE_PACKED_PIXELS,
+    .type_aux = 0,
+    .visual = FB_VISUAL_TRUECOLOR,
+    .xpanstep = 0,
+    .ypanstep = 1,
+    .ywrapstep = 0,
+    .accel = FB_ACCEL_NONE
+};
+
+static void v3s_clrbits(void __iomem *reg, uint32_t clr_val)
+{
+	uint32_t ret;
+
+	ret = readl(reg);
+	ret &= ~(clr_val);
+	writel(ret, reg);
+}
+
+static void v3s_setbits(void __iomem *reg, uint32_t set_val)
+{
+	uint32_t ret;
+
+	ret = readl(reg);
+	ret |= set_val;
+	writel(ret, reg);
+}
+
+static void v3s_i80_gpio_init(void)
+{
+    uint32_t r=0;
+
+    //PE0~7
+    r = readl(iomm.gpio + V3S_GPIOE_CFG0);
+    r&= 0x000f0000;
+    r|= 0x33303333;
+    writel(r, iomm.gpio + V3S_GPIOE_CFG0);
+
+    //PE8~15
+    r = readl(iomm.gpio + V3S_GPIOE_CFG1);
+    r&= 0xfff00000;
+    r|= 0x00033333;
+    writel(r, iomm.gpio + V3S_GPIOE_CFG1);
+
+    //PE2
+    r = readl(iomm.gpio + V3S_GPIOE_PUL0);
+    r &= 0xffffff0f;
+    r |= 0x00000010;
+    writel(r, iomm.gpio + V3S_GPIOE_PUL0);
+
+    //PB2
+    r = readl(iomm.gpio + V3S_GPIOB_CFG0);
+    r&= 0xfffff0ff;
+    r|= 0x00000100;
+    writel(r, iomm.gpio + V3S_GPIOB_CFG0);
+
+    //LCDreset
+    v3s_clrbits(iomm.gpio + V3S_GPIOB_DATA, (1 << 2));
+    mdelay(150);
+    v3s_setbits(iomm.gpio + V3S_GPIOB_DATA, (1 << 2));
+    mdelay(50);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+    uint32_t cnt = 0;
+
+    v3s_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));   //trigger mode enable
+    ndelay(10);
+    while(1) {
+        if(readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000) {
+            if(cnt > 100) {
+                return -1;
+            }
+            else {
+                cnt += 1;
+            }
+        }
+        break;
+    }
+    return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+    return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+    while(lcdc_wait_busy());
+    if(is_data) {
+        v3s_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    else {
+        v3s_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    while(lcdc_wait_busy());
+    writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+static void lcdc_st7789v_init(void)
+{
+    v3s_i80_gpio_init();
+
+    lcdc_wr(0, 0x11);  //sleep out
+    mdelay(250);
+
+    lcdc_wr(0, 0x36);
+    lcdc_wr(1, 0xB0);
+
+    lcdc_wr(0, 0x2a);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x01);
+    lcdc_wr(1, 0x3f);
+
+    lcdc_wr(0, 0x2b);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0xef);
+
+    // ST7789S Frame rate setting
+    lcdc_wr(0, 0xb2);
+    lcdc_wr(1, 0x0c);
+    lcdc_wr(1, 0x0c);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x33);
+    lcdc_wr(1, 0x33);
+
+    lcdc_wr(0, 0x20);  //Display Inversion Off
+
+    // Gate Control
+    lcdc_wr(0, 0xb7);
+    lcdc_wr(1, 0x56);
+
+    // ST7789S Power setting
+    lcdc_wr(0, 0xbb);
+    lcdc_wr(1, 0x18);
+
+    lcdc_wr(0, 0xc0);
+    lcdc_wr(1, 0x2c);
+
+    lcdc_wr(0, 0xc2);
+    lcdc_wr(1, 0x01);
+
+    lcdc_wr(0, 0xc3);
+    lcdc_wr(1, 0x1f);
+
+    lcdc_wr(0, 0xc4);
+    lcdc_wr(1, 0x20);
+
+    lcdc_wr(0, 0xc6);
+    lcdc_wr(1, 0x0f); // 0x04, 0x1f
+
+    lcdc_wr(0, 0xd0);
+    lcdc_wr(1, 0xa6);
+    lcdc_wr(1, 0xa1);
+
+    // ST7789S gamma setting
+    lcdc_wr(0, 0xe0);
+    lcdc_wr(1, 0x70);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x06);
+    lcdc_wr(1, 0x09);
+    lcdc_wr(1, 0x0b);
+    lcdc_wr(1, 0x2a);
+    lcdc_wr(1, 0x3c);
+    lcdc_wr(1, 0x33);
+    lcdc_wr(1, 0x4b);
+    lcdc_wr(1, 0x08);
+    lcdc_wr(1, 0x16);
+    lcdc_wr(1, 0x14);
+    lcdc_wr(1, 0x2a);
+    lcdc_wr(1, 0x23);
+
+    lcdc_wr(0, 0xe1);
+    lcdc_wr(1, 0xd0);
+    lcdc_wr(1, 0x00);
+    lcdc_wr(1, 0x06);
+    lcdc_wr(1, 0x09);
+    lcdc_wr(1, 0x0b);
+    lcdc_wr(1, 0x29);
+    lcdc_wr(1, 0x36);
+    lcdc_wr(1, 0x54);
+    lcdc_wr(1, 0x4b);
+    lcdc_wr(1, 0x0d);
+    lcdc_wr(1, 0x16);
+    lcdc_wr(1, 0x14);
+    lcdc_wr(1, 0x28);
+    lcdc_wr(1, 0x22);
+
+    lcdc_wr(0, 0x35);  //Memory data access control
+    lcdc_wr(1, 0x00);  //TE off
+    lcdc_wr(1, 0xaa);  //4us
+    lcdc_wr(1, 0x55);  //4us
+    lcdc_wr(1, 0x21);  //TE on
+
+    lcdc_wr(0, 0x3A);  //Interface pixel format
+    lcdc_wr(1, 0x55);  //65K
+
+    lcdc_wr(0, 0x21);  //ips Display inversion on
+    lcdc_wr(0, 0x29);  //Display on
+    lcdc_wr(0, 0x2c);  //Memory write
+}
+
+static void smartlcd_init(struct myfb_par *par)
+{
+    uint32_t ret=0, bp=0, total=0, i=0;
+    uint32_t h_front_porch = 8;
+    uint32_t h_back_porch = 8;
+    uint32_t h_sync_len = 1;
+    uint32_t v_front_porch = 8;
+    uint32_t v_back_porch = 10;
+    uint32_t v_sync_len = 1;
+
+    struct de_clk_t * clk = (struct de_clk_t *)(iomm.de);
+	struct de_glb_t * glb = (struct de_glb_t *)(iomm.de + V3S_DE_MUX_GLB);
+	struct de_bld_t * bld = (struct de_bld_t *)(iomm.de + V3S_DE_MUX_BLD);
+	struct de_ui_t * ui = (struct de_ui_t *)(iomm.de + V3S_DE_MUX_CHAN + 0x1000 * 2);
+
+    //tcon0 disable
+    writel(0, iomm.lcdc + TCON_CTRL_REG);
+    writel(0, iomm.lcdc + TCON_INT_REG0);
+    ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+    ret &= ~(0xf << 28);
+    writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    //de set mod
+    v3s_setbits(&clk->rst_cfg, (1 << 0));
+    v3s_setbits(&clk->gate_cfg, (1 << 0));
+    v3s_setbits(&clk->bus_cfg, (1 << 0));
+    v3s_setbits(&clk->sel_cfg, (1 << 0));
+
+    v3s_setbits(&glb->ctl, (1 << 0));
+    writel(0, &glb->status);
+    writel(1, &glb->dbuff);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &glb->size);
+
+    for(i = 0; i < 4; i++) {
+		void * chan = (void *)(iomm.de + V3S_DE_MUX_CHAN + 0x1000 * i);
+		memset(chan, 0, i == 0 ? sizeof(struct de_vi_t) : sizeof(struct de_ui_t));
+	}
+	memset(bld, 0, sizeof(struct de_bld_t));
+
+    writel(0x00000101, &bld->fcolor_ctl);
+	writel(2, &bld->route);
+	writel(0, &bld->premultiply);
+	writel(0xff000000, &bld->bkcolor);
+	writel(0x03010301, &bld->bld_mode[0]);
+	writel(0x03010301, &bld->bld_mode[1]);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &bld->output_size);
+	writel(0, &bld->out_ctl);
+	writel(0, &bld->ck_ctl);
+
+	for(i = 0; i < 4; i++) {
+		writel(0xff000000, &bld->attr[i].fcolor);
+		writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &bld->attr[i].insize);
+	}
+
+    writel(0, iomm.de + V3S_DE_MUX_VSU);
+	writel(0, iomm.de + V3S_DE_MUX_GSU1);
+	writel(0, iomm.de + V3S_DE_MUX_GSU2);
+	writel(0, iomm.de + V3S_DE_MUX_GSU3);
+	writel(0, iomm.de + V3S_DE_MUX_FCE);
+	writel(0, iomm.de + V3S_DE_MUX_BWS);
+	writel(0, iomm.de + V3S_DE_MUX_LTI);
+	writel(0, iomm.de + V3S_DE_MUX_PEAK);
+	writel(0, iomm.de + V3S_DE_MUX_ASE);
+	writel(0, iomm.de + V3S_DE_MUX_FCC);
+	writel(0, iomm.de + V3S_DE_MUX_DCSC);
+
+	writel((1 << 0) | (10 << 8) | (1 << 1) | (0xff << 24), &ui->cfg[0].attr);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &ui->cfg[0].size);
+	writel(0, &ui->cfg[0].coord);
+	writel((par->bpp / 8) * (par->mode.xres), &ui->cfg[0].pitch);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), &ui->ovl_size);
+
+    //de set address
+	writel((uint32_t)par->vram_phys, &ui->cfg[0].top_laddr);
+
+    //de enable
+    writel(1, &glb->dbuff);
+
+    //tcon set mode
+    ret = (v_front_porch + v_back_porch + v_sync_len);
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+    writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel((7 << 29), iomm.lcdc + TCON0_CPU_IF_REG);
+
+    writel(((par->mode.xres - 1) << 16) | ((par->mode.yres - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+    bp = h_sync_len + h_back_porch;
+    total = (par->mode.xres) * 2 + h_front_porch + bp;
+    writel(((total - 1) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+    bp = v_sync_len + v_back_porch;
+    total = par->mode.yres + v_front_porch + bp;
+    writel(((total * 2) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+    writel(((h_sync_len - 1) << 16) | ((v_sync_len - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+
+    writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+    writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+    writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    writel(((((par->mode.xres) + h_front_porch + bp - 1) << 16)), iomm.lcdc + TCON0_CPU_TRI0_REG);   //block space
+    writel((par->mode.yres - 1), iomm.lcdc + TCON0_CPU_TRI1_REG);   //block num
+    writel(((7 << 15) | (par->mode.xres - 1)), iomm.lcdc + TCON0_CPU_TRI2_REG);//start delay3, Trans Start
+    v3s_setbits(iomm.lcdc + TCON0_CPU_TRI3_REG, (2 << 28));         //TE falling mode
+
+    //tcon enable
+    v3s_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+    lcdc_st7789v_init();
+
+    v3s_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 26));
+    v3s_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+    v3s_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 26) | (1 << 17));
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg) {
+    v3s_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 10));
+    return IRQ_HANDLED;
+}
+
+static void v3s_enable_irq(struct myfb_par *par)
+{
+    int ret = 0;
+
+    par->lcdc_irq = platform_get_irq(par->pdev, 0);
+    if(par->lcdc_irq < 0) {
+        printk("%s, failed to get irq number for lcdc irq\n", __func__);
+    }
+    else {
+        ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "lcdc_irq", par);
+        if(ret) {
+            printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+        }
+    }
+}
+
+static void v3s_clock_init(struct myfb_par *par)
+{
+    writel(0x91001f06, iomm.ccm + PLL_VIDEO_CTRL_REG);
+    while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+    while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+    v3s_setbits(iomm.ccm + DE_CLK_REG, (1 << 31));
+    v3s_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31));
+    v3s_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 12) | (1 << 4));
+    v3s_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 12) | (1 << 4));
+}
+
+static void lcd_delay_init(unsigned long param)
+{
+    v3s_clock_init(mypar);
+    smartlcd_init(mypar);
+    v3s_enable_irq(mypar);
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+    red = CNVT_TOHW(red, info->var.red.length);
+    blue = CNVT_TOHW(blue, info->var.blue.length);
+    green = CNVT_TOHW(green, info->var.green.length);
+    ((uint32_t *)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+    return 0;
+}
+#undef CNVT_TOHW
+
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    int bpp = var->bits_per_pixel >> 3;
+    struct myfb_par *par = info->par;
+    unsigned long line_size = var->xres_virtual * bpp;
+
+    if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)) {
+        return -EINVAL;
+    }
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->red.offset = 11;
+    var->red.length = 5;
+    var->green.offset = 5;
+    var->green.length = 6;
+    var->blue.offset = 0;
+    var->blue.length = 5;
+    var->red.msb_right = 0;
+    var->green.msb_right = 0;
+    var->blue.msb_right = 0;
+    var->transp.msb_right = 0;
+    if(line_size * var->yres_virtual > par->vram_size) {
+        var->yres_virtual = par->vram_size / line_size;
+    }
+    if(var->yres > var->yres_virtual) {
+        var->yres = var->yres_virtual;
+    }
+    if(var->xres > var->xres_virtual) {
+        var->xres = var->xres_virtual;
+    }
+    if(var->xres + var->xoffset > var->xres_virtual) {
+        var->xoffset = var->xres_virtual - var->xres;
+    }
+    if(var->yres + var->yoffset > var->yres_virtual) {
+        var->yoffset = var->yres_virtual - var->yres;
+    }
+    return 0;
+}
+
+static int myfb_set_par(struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    fb_var_to_videomode(&par->mode, &info->var);
+    par->yoffset = info->var.yoffset = 0;
+    par->bpp = info->var.bits_per_pixel;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.line_length = (par->mode.xres * par->bpp) / 8;
+
+    return 0;
+}
+
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+    switch (cmd) {
+        case FBIO_WAITFORVSYNC:
+            break;			
+    }
+    return 0;
+}
+
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+    const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+    const unsigned long size = vma->vm_end - vma->vm_start;
+
+    if(offset + size > info->fix.smem_len) {
+        return -EINVAL;
+    }
+
+    if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)) {
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    if((var->xoffset != info->var.xoffset) || (var->yoffset != info->var.yoffset)){
+        info->var.xoffset = var->xoffset;
+        info->var.yoffset = var->yoffset;
+        par->yoffset = var->yoffset;
+    }
+
+    return 0;
+}
+
+static struct fb_ops myfb_ops = {
+    .owner          = THIS_MODULE,
+    .fb_check_var   = myfb_check_var,
+    .fb_set_par     = myfb_set_par,
+    .fb_setcolreg   = myfb_setcolreg,
+    .fb_pan_display = myfb_pan_display,
+    .fb_ioctl       = myfb_ioctl,
+    .fb_mmap        = myfb_mmap,
+
+    .fb_fillrect  = sys_fillrect,
+    .fb_copyarea  = sys_copyarea,
+    .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+    int ret = 0;
+    struct fb_info *info = NULL;
+    struct myfb_par *par = NULL;
+    struct fb_videomode *mode = NULL;
+
+    mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+    if(mode == NULL) {
+        return -ENOMEM;
+    }
+    mode->name = "320x240";
+    mode->xres = 320;
+    mode->yres = 240;
+    mode->vmode = FB_VMODE_NONINTERLACED;
+    pm_runtime_enable(&device->dev);
+    pm_runtime_get_sync(&device->dev);
+
+    info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+    if(!info) {
+        return -ENOMEM;
+    }
+
+    par = info->par;
+    par->pdev = device;
+    par->dev = &device->dev;
+    par->bpp = 16;
+    fb_videomode_to_var(&myfb_var, mode);
+
+    par->vram_size = (320 * 240 * 2 * 2);
+    par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t *)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+    if(!par->vram_virt) {
+        return -EINVAL;
+    }
+    info->screen_base = (char __iomem *)par->vram_virt;
+    myfb_fix.smem_start = par->vram_phys;
+    myfb_fix.smem_len = par->vram_size;
+    myfb_fix.line_length = 320 * 2;
+
+    par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t *)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+    if(!par->v_palette_base) {
+        return -EINVAL;
+    }
+    memset(par->v_palette_base, 0, PALETTE_SIZE);
+    myfb_var.grayscale = 0;
+    myfb_var.bits_per_pixel = par->bpp;
+
+    info->flags = FBINFO_FLAG_DEFAULT;
+    info->fix = myfb_fix;
+    info->var = myfb_var;
+    info->fbops = &myfb_ops;
+    info->pseudo_palette = par->pseudo_palette;
+    info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+    ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+    if(ret) {
+        return -EINVAL;
+    }
+    info->cmap.len = 32;
+
+    myfb_var.activate = FB_ACTIVATE_FORCE;
+    fb_set_var(info, &myfb_var);
+    dev_set_drvdata(&device->dev, info);
+    if(register_framebuffer(info) < 0) {
+        return -EINVAL;
+    }
+
+    mypar = par;
+
+    for(ret = 0; ret < of_clk_get_parent_count(device->dev.of_node); ret++) {
+        clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+    }
+    fb_prepare_logo(info, 0);
+    fb_show_logo(info, 0);
+
+    setup_timer(&mytimer, lcd_delay_init, 0);
+    mod_timer(&mytimer, jiffies + HZ);
+
+    return 0;
+}
+
+static int myfb_remove(struct platform_device *dev)
+{
+    struct fb_info *info = dev_get_drvdata(&dev->dev);
+    struct myfb_par *par = info->par;
+
+    if(info) {
+        free_irq(par->lcdc_irq, par);
+        del_timer(&mytimer);
+        flush_scheduled_work();
+        unregister_framebuffer(info);
+        fb_dealloc_cmap(&info->cmap);
+        dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+        dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+        pm_runtime_put_sync(&dev->dev);
+        pm_runtime_disable(&dev->dev);
+        framebuffer_release(info);
+    }
+    return 0;
+}
+
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    fb_set_suspend(info, 1);
+    pm_runtime_put_sync(&dev->dev);
+    console_unlock();
+    return 0;
+}
+
+static int myfb_resume(struct platform_device *dev)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    pm_runtime_get_sync(&dev->dev);
+    fb_set_suspend(info, 0);
+    console_unlock();
+    return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+    {
+        .compatible = "allwinner,sun8i-v3s-tcon0",
+    },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+
+static struct platform_driver fb_driver = {
+    .probe    = myfb_probe,
+    .remove   = myfb_remove,
+    .suspend  = myfb_suspend,
+    .resume   = myfb_resume,
+    .driver = {
+        .name   = DRIVER_NAME,
+        .owner  = THIS_MODULE,
+        .of_match_table = of_match_ptr(fb_of_match),
+    },
+};
+
+static int myopen(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    return 0;
+}
+
+static const struct file_operations myfops = {
+        .owner = THIS_MODULE,
+        .open = myopen,
+        .release = myclose,
+        .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+    iomm.ccm = (uint8_t *)ioremap(V3S_CCM_BASE, 0x400);
+    iomm.gpio = (uint8_t *)ioremap(V3S_GPIO_BASE, 0x400);
+    iomm.lcdc = (uint8_t *)ioremap(V3S_TCON0_BASE, 0x1000);
+    iomm.de = (uint8_t *)ioremap(V3S_DE_BASE, 0x200000);
+    alloc_chrdev_region(&major, 0, 1, "miyoo_fb0");
+    myclass = class_create(THIS_MODULE, "miyoo_fb0");
+    device_create(myclass, NULL, major, NULL, "miyoo_fb0");
+    cdev_init(&mycdev, &myfops);
+    cdev_add(&mycdev, major, 1);
+    return platform_driver_register(&fb_driver);
+}
+
+static void __exit fb_cleanup(void)
+{
+    iounmap(iomm.ccm);
+    iounmap(iomm.gpio);
+    iounmap(iomm.lcdc);
+    iounmap(iomm.de);
+    device_destroy(myclass, major);
+    cdev_del(&mycdev);
+    class_destroy(myclass);
+    unregister_chrdev_region(major, 1);
+    platform_driver_unregister(&fb_driver);
+}
+
+module_init(fb_init);
+module_exit(fb_cleanup);
+
+MODULE_DESCRIPTION("I80 Framebuffer driver for V3S");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
diff -uprN a/include/linux/overflow.h b/include/linux/overflow.h
--- a/include/linux/overflow.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/overflow.h	2025-04-27 09:53:03.372561954 +0800
@@ -0,0 +1,310 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+#ifndef __LINUX_OVERFLOW_H
+#define __LINUX_OVERFLOW_H
+
+#include <linux/compiler.h>
+#include <linux/limits.h>
+
+/*
+ * In the fallback code below, we need to compute the minimum and
+ * maximum values representable in a given type. These macros may also
+ * be useful elsewhere, so we provide them outside the
+ * COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW block.
+ *
+ * It would seem more obvious to do something like
+ *
+ * #define type_min(T) (T)(is_signed_type(T) ? (T)1 << (8*sizeof(T)-1) : 0)
+ * #define type_max(T) (T)(is_signed_type(T) ? ((T)1 << (8*sizeof(T)-1)) - 1 : ~(T)0)
+ *
+ * Unfortunately, the middle expressions, strictly speaking, have
+ * undefined behaviour, and at least some versions of gcc warn about
+ * the type_max expression (but not if -fsanitize=undefined is in
+ * effect; in that case, the warning is deferred to runtime...).
+ *
+ * The slightly excessive casting in type_min is to make sure the
+ * macros also produce sensible values for the exotic type _Bool. [The
+ * overflow checkers only almost work for _Bool, but that's
+ * a-feature-not-a-bug, since people shouldn't be doing arithmetic on
+ * _Bools. Besides, the gcc builtins don't allow _Bool* as third
+ * argument.]
+ *
+ * Idea stolen from
+ * https://mail-index.netbsd.org/tech-misc/2007/02/05/0000.html -
+ * credit to Christian Biere.
+ */
+#define is_signed_type(type)       (((type)(-1)) < (type)1)
+#define __type_half_max(type) ((type)1 << (8*sizeof(type) - 1 - is_signed_type(type)))
+#define type_max(T) ((T)((__type_half_max(T) - 1) + __type_half_max(T)))
+#define type_min(T) ((T)((T)-type_max(T)-(T)1))
+
+
+#ifdef COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW
+/*
+ * For simplicity and code hygiene, the fallback code below insists on
+ * a, b and *d having the same type (similar to the min() and max()
+ * macros), whereas gcc's type-generic overflow checkers accept
+ * different types. Hence we don't just make check_add_overflow an
+ * alias for __builtin_add_overflow, but add type checks similar to
+ * below.
+ */
+#define check_add_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	__builtin_add_overflow(__a, __b, __d);	\
+})
+
+#define check_sub_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	__builtin_sub_overflow(__a, __b, __d);	\
+})
+
+#define check_mul_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	__builtin_mul_overflow(__a, __b, __d);	\
+})
+
+#else
+
+
+/* Checking for unsigned overflow is relatively easy without causing UB. */
+#define __unsigned_add_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = __a + __b;			\
+	*__d < __a;				\
+})
+#define __unsigned_sub_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = __a - __b;			\
+	__a < __b;				\
+})
+/*
+ * If one of a or b is a compile-time constant, this avoids a division.
+ */
+#define __unsigned_mul_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);				\
+	typeof(b) __b = (b);				\
+	typeof(d) __d = (d);				\
+	(void) (&__a == &__b);				\
+	(void) (&__a == __d);				\
+	*__d = __a * __b;				\
+	__builtin_constant_p(__b) ?			\
+	  __b > 0 && __a > type_max(typeof(__a)) / __b : \
+	  __a > 0 && __b > type_max(typeof(__b)) / __a;	 \
+})
+
+/*
+ * For signed types, detecting overflow is much harder, especially if
+ * we want to avoid UB. But the interface of these macros is such that
+ * we must provide a result in *d, and in fact we must produce the
+ * result promised by gcc's builtins, which is simply the possibly
+ * wrapped-around value. Fortunately, we can just formally do the
+ * operations in the widest relevant unsigned type (u64) and then
+ * truncate the result - gcc is smart enough to generate the same code
+ * with and without the (u64) casts.
+ */
+
+/*
+ * Adding two signed integers can overflow only if they have the same
+ * sign, and overflow has happened iff the result has the opposite
+ * sign.
+ */
+#define __signed_add_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = (u64)__a + (u64)__b;		\
+	(((~(__a ^ __b)) & (*__d ^ __a))	\
+		& type_min(typeof(__a))) != 0;	\
+})
+
+/*
+ * Subtraction is similar, except that overflow can now happen only
+ * when the signs are opposite. In this case, overflow has happened if
+ * the result has the opposite sign of a.
+ */
+#define __signed_sub_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = (u64)__a - (u64)__b;		\
+	((((__a ^ __b)) & (*__d ^ __a))		\
+		& type_min(typeof(__a))) != 0;	\
+})
+
+/*
+ * Signed multiplication is rather hard. gcc always follows C99, so
+ * division is truncated towards 0. This means that we can write the
+ * overflow check like this:
+ *
+ * (a > 0 && (b > MAX/a || b < MIN/a)) ||
+ * (a < -1 && (b > MIN/a || b < MAX/a) ||
+ * (a == -1 && b == MIN)
+ *
+ * The redundant casts of -1 are to silence an annoying -Wtype-limits
+ * (included in -Wextra) warning: When the type is u8 or u16, the
+ * __b_c_e in check_mul_overflow obviously selects
+ * __unsigned_mul_overflow, but unfortunately gcc still parses this
+ * code and warns about the limited range of __b.
+ */
+
+#define __signed_mul_overflow(a, b, d) ({				\
+	typeof(a) __a = (a);						\
+	typeof(b) __b = (b);						\
+	typeof(d) __d = (d);						\
+	typeof(a) __tmax = type_max(typeof(a));				\
+	typeof(a) __tmin = type_min(typeof(a));				\
+	(void) (&__a == &__b);						\
+	(void) (&__a == __d);						\
+	*__d = (u64)__a * (u64)__b;					\
+	(__b > 0   && (__a > __tmax/__b || __a < __tmin/__b)) ||	\
+	(__b < (typeof(__b))-1  && (__a > __tmin/__b || __a < __tmax/__b)) || \
+	(__b == (typeof(__b))-1 && __a == __tmin);			\
+})
+
+
+#define check_add_overflow(a, b, d)					\
+	__builtin_choose_expr(is_signed_type(typeof(a)),		\
+			__signed_add_overflow(a, b, d),			\
+			__unsigned_add_overflow(a, b, d))
+
+#define check_sub_overflow(a, b, d)					\
+	__builtin_choose_expr(is_signed_type(typeof(a)),		\
+			__signed_sub_overflow(a, b, d),			\
+			__unsigned_sub_overflow(a, b, d))
+
+#define check_mul_overflow(a, b, d)					\
+	__builtin_choose_expr(is_signed_type(typeof(a)),		\
+			__signed_mul_overflow(a, b, d),			\
+			__unsigned_mul_overflow(a, b, d))
+
+
+#endif /* COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW */
+
+/** check_shl_overflow() - Calculate a left-shifted value and check overflow
+ *
+ * @a: Value to be shifted
+ * @s: How many bits left to shift
+ * @d: Pointer to where to store the result
+ *
+ * Computes *@d = (@a << @s)
+ *
+ * Returns true if '*d' cannot hold the result or when 'a << s' doesn't
+ * make sense. Example conditions:
+ * - 'a << s' causes bits to be lost when stored in *d.
+ * - 's' is garbage (e.g. negative) or so large that the result of
+ *   'a << s' is guaranteed to be 0.
+ * - 'a' is negative.
+ * - 'a << s' sets the sign bit, if any, in '*d'.
+ *
+ * '*d' will hold the results of the attempted shift, but is not
+ * considered "safe for use" if false is returned.
+ */
+#define check_shl_overflow(a, s, d) ({					\
+	typeof(a) _a = a;						\
+	typeof(s) _s = s;						\
+	typeof(d) _d = d;						\
+	u64 _a_full = _a;						\
+	unsigned int _to_shift =					\
+		_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;		\
+	*_d = (_a_full << _to_shift);					\
+	(_to_shift != _s || *_d < 0 || _a < 0 ||			\
+		(*_d >> _to_shift) != _a);				\
+})
+
+/**
+ * array_size() - Calculate size of 2-dimensional array.
+ *
+ * @a: dimension one
+ * @b: dimension two
+ *
+ * Calculates size of 2-dimensional array: @a * @b.
+ *
+ * Returns: number of bytes needed to represent the array or SIZE_MAX on
+ * overflow.
+ */
+static inline __must_check size_t array_size(size_t a, size_t b)
+{
+	size_t bytes;
+
+	if (check_mul_overflow(a, b, &bytes))
+		return SIZE_MAX;
+
+	return bytes;
+}
+
+/**
+ * array3_size() - Calculate size of 3-dimensional array.
+ *
+ * @a: dimension one
+ * @b: dimension two
+ * @c: dimension three
+ *
+ * Calculates size of 3-dimensional array: @a * @b * @c.
+ *
+ * Returns: number of bytes needed to represent the array or SIZE_MAX on
+ * overflow.
+ */
+static inline __must_check size_t array3_size(size_t a, size_t b, size_t c)
+{
+	size_t bytes;
+
+	if (check_mul_overflow(a, b, &bytes))
+		return SIZE_MAX;
+	if (check_mul_overflow(bytes, c, &bytes))
+		return SIZE_MAX;
+
+	return bytes;
+}
+
+static inline __must_check size_t __ab_c_size(size_t n, size_t size, size_t c)
+{
+	size_t bytes;
+
+	if (check_mul_overflow(n, size, &bytes))
+		return SIZE_MAX;
+	if (check_add_overflow(bytes, c, &bytes))
+		return SIZE_MAX;
+
+	return bytes;
+}
+
+/**
+ * struct_size() - Calculate size of structure with trailing array.
+ * @p: Pointer to the structure.
+ * @member: Name of the array member.
+ * @n: Number of elements in the array.
+ *
+ * Calculates size of memory needed for structure @p followed by an
+ * array of @n @member elements.
+ *
+ * Return: number of bytes needed or SIZE_MAX on overflow.
+ */
+#define struct_size(p, member, n)					\
+	__ab_c_size(n,							\
+		    sizeof(*(p)->member) + __must_be_array((p)->member),\
+		    sizeof(*(p)))
+
+#endif /* __LINUX_OVERFLOW_H */
